# src/data/processor.py
import pandas as pd
import numpy as np
from datetime import datetime
import logging

logger = logging.getLogger(__name__)

class DataProcessor:
    def __init__(self):
        pass
    
    def klines_to_dataframe(self, klines):
        """
        Convierte datos de velas (klines) de Binance a un DataFrame de pandas.
        
        Args:
            klines (list): Lista de velas de Binance
            
        Returns:
            pandas.DataFrame: DataFrame con los datos procesados
        """
        columns = [
            'timestamp', 'open', 'high', 'low', 'close', 'volume',
            'close_time', 'quote_asset_volume', 'number_of_trades',
            'taker_buy_base_asset_volume', 'taker_buy_quote_asset_volume', 'ignore'
        ]
        
        df = pd.DataFrame(klines, columns=columns)
        
        # Convertir tipos de datos
        numeric_columns = ['open', 'high', 'low', 'close', 'volume', 
                          'quote_asset_volume', 'taker_buy_base_asset_volume', 
                          'taker_buy_quote_asset_volume']
        
        df[numeric_columns] = df[numeric_columns].astype(float)
        
        # Convertir timestamps a datetime
        df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
        df['close_time'] = pd.to_datetime(df['close_time'], unit='ms')
        
        # Establecer timestamp como índice
        df.set_index('timestamp', inplace=True)
        
        logger.info(f"DataFrame creado con {len(df)} filas")
        return df
    
    def add_indicators(self, df):
        """
        Añade indicadores técnicos al DataFrame.
        
        Args:
            df (pandas.DataFrame): DataFrame con datos OHLCV
            
        Returns:
            pandas.DataFrame: DataFrame con indicadores añadidos
        """
        # Copiar el DataFrame para no modificar el original
        df_with_indicators = df.copy()
        
        try:
            # Calcular medias móviles (optimizadas para velas de 1h)
            df_with_indicators['sma_20'] = df_with_indicators['close'].rolling(window=20).mean()  # 20 horas
            df_with_indicators['sma_50'] = df_with_indicators['close'].rolling(window=50).mean()  # ~2 días
            df_with_indicators['sma_200'] = df_with_indicators['close'].rolling(window=200).mean()  # ~8 días
            
            # Calcular RSI (Relative Strength Index)
            delta = df_with_indicators['close'].diff()
            gain = delta.where(delta > 0, 0)
            loss = -delta.where(delta < 0, 0)
            
            avg_gain = gain.rolling(window=14).mean()
            avg_loss = loss.rolling(window=14).mean()
            
            rs = avg_gain / avg_loss
            df_with_indicators['rsi_14'] = 100 - (100 / (1 + rs))
            
            # Calcular MACD (Moving Average Convergence Divergence)
            ema_12 = df_with_indicators['close'].ewm(span=12, adjust=False).mean()
            ema_26 = df_with_indicators['close'].ewm(span=26, adjust=False).mean()
            df_with_indicators['macd'] = ema_12 - ema_26
            df_with_indicators['macd_signal'] = df_with_indicators['macd'].ewm(span=9, adjust=False).mean()
            df_with_indicators['macd_histogram'] = df_with_indicators['macd'] - df_with_indicators['macd_signal']
            
            # Calcular Bandas de Bollinger
            df_with_indicators['bollinger_mid'] = df_with_indicators['close'].rolling(window=20).mean()
            df_with_indicators['bollinger_std'] = df_with_indicators['close'].rolling(window=20).std()
            df_with_indicators['bollinger_upper'] = df_with_indicators['bollinger_mid'] + 2 * df_with_indicators['bollinger_std']
            df_with_indicators['bollinger_lower'] = df_with_indicators['bollinger_mid'] - 2 * df_with_indicators['bollinger_std']
            
            # Añadir ADX (Average Directional Index) - bueno para Solana
            high_low = df_with_indicators['high'] - df_with_indicators['low']
            high_close = abs(df_with_indicators['high'] - df_with_indicators['close'].shift())
            low_close = abs(df_with_indicators['low'] - df_with_indicators['close'].shift())
            
            tr = pd.DataFrame(np.maximum(high_low, np.maximum(high_close, low_close)))
            tr.columns = ['TR']
            
            atr = tr.rolling(window=14).mean()
            df_with_indicators['atr_14'] = atr
            
            # Eliminar filas con NaN (debido a las ventanas de cálculo)
            df_with_indicators.dropna(inplace=True)
            
            logger.info(f"Indicadores técnicos añadidos al DataFrame, filas restantes: {len(df_with_indicators)}")
        except Exception as e:
            logger.error(f"Error al añadir indicadores: {e}")
        
        return df_with_indicators
    
    def prepare_for_model(self, df, window_size=10):
        """
        Prepara los datos para el modelo de aprendizaje automático.
        
        Args:
            df (pandas.DataFrame): DataFrame con datos e indicadores
            window_size (int): Tamaño de la ventana para características secuenciales
            
        Returns:
            tuple: (X, y) donde X son las características y y son las etiquetas
   df_with_indicators.dropna(inplace=True)        """
        logger.info(f"Preparando datos para modelo, DataFrame de entrada: {len(df)} filas")
        
        if len(df) <= window_size:
            logger.warning(f"No hay suficientes datos para crear secuencias (necesita > {window_size} filas)")
            return np.array([]), np.array([])
        
        # Crear etiquetas: 1 si el precio sube en el siguiente período, 0 si baja
        df['target'] = (df['close'].shift(-1) > df['close']).astype(int)
        
        # Seleccionar características
        features = [
            'open', 'high', 'low', 'close', 'volume',
            'sma_20', 'sma_50', 'sma_200', 'rsi_14',
            'macd', 'macd_signal', 'macd_histogram',
            'bollinger_upper', 'bollinger_mid', 'bollinger_lower',
            'atr_14'  # Añadido ATR para Solana
        ]
        
        # Verificar que todas las características existen en el DataFrame
        missing_features = [f for f in features if f not in df.columns]
        if missing_features:
            logger.error(f"Faltan características en el DataFrame: {missing_features}")
            # Si faltan características, usar solo las que están disponibles
            features = [f for f in features if f in df.columns]
            logger.info(f"Usando características disponibles: {features}")
        
        try:
            # Normalizar características
            df_normalized = df[features].copy()
            for column in df_normalized.columns:
                mean = df_normalized[column].mean()
                std = df_normalized[column].std()
                if std == 0:
                    logger.warning(f"Desviación estándar cero para {column}, no se normalizará")
                    continue
                df_normalized[column] = (df_normalized[column] - mean) / std
            
            # Crear secuencias
            X = []
            y = []
            
            logger.info(f"Creando secuencias con window_size={window_size}, datos disponibles: {len(df_normalized)}")
            
            for i in range(len(df_normalized) - window_size):
                X.append(df_normalized.iloc[i:i+window_size].values)
                y.append(df['target'].iloc[i+window_size])
            
            X = np.array(X)
            y = np.array(y)
            
            logger.info(f"Datos preparados para modelo: X shape {X.shape}, y shape {y.shape}")
            return X, y
        except Exception as e:
            logger.error(f"Error al preparar datos para modelo: {e}")
            return np.array([]), np.array([])
