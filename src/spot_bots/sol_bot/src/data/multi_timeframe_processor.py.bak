# src/data/multi_timeframe_processor.py
import pandas as pd
import numpy as np
from datetime import datetime
import logging
from src.data.processor import DataProcessor

logger = logging.getLogger(__name__)

class MultiTimeframeProcessor:
    def __init__(self):
        self.processor = DataProcessor()
    
    def process_multiple_timeframes(self, klines_1h, klines_4h, klines_1d):
        """
        Procesa datos de múltiples timeframes y combina la información.
        
        Args:
            klines_1h (list): Lista de velas de 1 hora
            klines_4h (list): Lista de velas de 4 horas
            klines_1d (list): Lista de velas de 1 día
            
        Returns:
            pandas.DataFrame: DataFrame con datos de 1h enriquecidos con información de timeframes superiores
        """
        # Procesar cada timeframe
        df_1h = self.processor.klines_to_dataframe(klines_1h)
        df_4h = self.processor.klines_to_dataframe(klines_4h)
        df_1d = self.processor.klines_to_dataframe(klines_1d)
        
        # Añadir indicadores a cada timeframe
        df_1h = self.processor.add_indicators(df_1h)
        df_4h = self.processor.add_indicators(df_4h)
        df_1d = self.processor.add_indicators(df_1d)
        
        # Preparar datos para modelo en cada timeframe
        df_1h = self.processor.prepare_data_for_model(df_1h)
        df_4h = self.processor.prepare_data_for_model(df_4h)
        df_1d = self.processor.prepare_data_for_model(df_1d)
        
        # Añadir características de timeframes superiores al dataframe de 1h
        df_enriched = self._enrich_with_higher_timeframes(df_1h, df_4h, df_1d)
        
        logger.info(f"DataFrame enriquecido con múltiples timeframes: {len(df_enriched)} filas")
        return df_enriched
    
    def _enrich_with_higher_timeframes(self, df_1h, df_4h, df_1d):
        """
        Enriquece el DataFrame de 1h con información de timeframes superiores.
        """
        # Crear copias para no modificar los originales
        df_1h_copy = df_1h.copy()
        
        # Añadir columnas para tendencias de timeframes superiores
        df_1h_copy['trend_4h'] = np.nan
        df_1h_copy['trend_1d'] = np.nan
        df_1h_copy['rsi_4h'] = np.nan
        df_1h_copy['rsi_1d'] = np.nan
        df_1h_copy['macd_4h'] = np.nan
        df_1h_copy['macd_1d'] = np.nan
        
        # Recorrer el dataframe de 1h
        for idx, row in df_1h_copy.iterrows():
            # Encontrar la vela de 4h correspondiente
            df_4h_prev = df_4h[df_4h.index <= idx]
            if not df_4h_prev.empty:
                latest_4h_idx = df_4h_prev.index[-1]
                df_1h_copy.at[idx, 'trend_4h'] = 1 if df_4h.at[latest_4h_idx, 'close'] > df_4h.at[latest_4h_idx, 'open'] else -1
                if 'rsi' in df_4h.columns:
                    df_1h_copy.at[idx, 'rsi_4h'] = df_4h.at[latest_4h_idx, 'rsi']
                if 'macd' in df_4h.columns:
                    df_1h_copy.at[idx, 'macd_4h'] = df_4h.at[latest_4h_idx, 'macd']
            
            # Encontrar la vela de 1d correspondiente
            df_1d_prev = df_1d[df_1d.index <= idx]
            if not df_1d_prev.empty:
                latest_1d_idx = df_1d_prev.index[-1]
                df_1h_copy.at[idx, 'trend_1d'] = 1 if df_1d.at[latest_1d_idx, 'close'] > df_1d.at[latest_1d_idx, 'open'] else -1
                if 'rsi' in df_1d.columns:
                    df_1h_copy.at[idx, 'rsi_1d'] = df_1d.at[latest_1d_idx, 'rsi']
                if 'macd' in df_1d.columns:
                    df_1h_copy.at[idx, 'macd_1d'] = df_1d.at[latest_1d_idx, 'macd']
        
        # Rellenar valores NaN
        df_1h_copy.fillna(method='bfill', inplace=True)
        df_1h_copy.fillna(method='ffill', inplace=True)
        
        return df_1h_copy

